


----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
--
--	HELP PANEL MANAGER
--	This system manages the state of the help panel, handling back/forward requests 
--	we're interested it replaces the contents of the tooltip with info from the db.
-- 	It also handles tooltip mouseover event listening.
--
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------


-- panel position overrides
help_panel_position_overrides_campaign = {
	["diplomacy_dropdown"] = {
		["x"] = "middle",
		["y"] = 50,
		["max_height"] = 500,
		["is_active"] = false,
		["redocking_wait_period"] = 0.3
	},
	
	["pre_battle_screen"] = {
		["x"] = "middle",
		["y"] = 50,
		["max_height"] = 500,
		["always_close"] = true,
		["is_active"] = false,
		["redocking_wait_period"] = 0.3
	},
	
	["post_battle_screen"] = {
		["x"] = "middle",
		["y"] = 50,
		["max_height"] = 500,
		["is_active"] = false,
		["redocking_wait_period"] = 0.3
	},
	
	["clan"] = {
		["x"] = 5,
		["y"] = -5,
		["is_active"] = false
	},
	
	["offices"] = {
		["x"] = 5,
		["y"] = -20,
		["is_active"] = false
	},
	
	["book_of_grudges"] = {
		["x"] = 5,
		["y"] = -5,
		["is_active"] = false
	},

	["character_details_panel"] = {
		["x"] = 5,
		["y"] = -5,
		["is_active"] = false
	},
	
	["technology_panel"] = {
		["x"] = 5,
		["y"] = -5,
		["is_active"] = false
	},
	
	["campaign_tactical_map"] = {
		["x"] = 5,
		["y"] = -5,
		["is_active"] = false,
		["cede_priority_to"] = "diplomacy_dropdown"
	},
	
	["end_turn_warning"] = {
		["x"] = 5,
		["y"] = -5,
		["is_active"] = false,
		["priority"] = 300
	},
	
	["mortuary_cult"] = {
		["x"] = 5,
		["y"] = -5,
		["is_active"] = false
	}
};


help_panel_position_overrides_battle = {

};


	

	





__help_page_manager = nil;

help_page_manager = {
	uic_help_panel = false,
	
	parser = false,
	
	overrides_table = false,
	
	title_bar_buttons_visible = true,
	
	-- hyperlink click listener
	hyperlink_click_listeners = {},
	hyperlink_click_listener_started = false,
	
	-- tooltip mouseover listeners
	tooltip_mouseover_listeners = {},
	active_tooltip_mouseover_listeners = {},
	tooltip_mouseover_listeners_started = false,
	
	help_page_history = {},
	help_page_history_max_size = 20,
	history_pointer = 0,
	
	-- panel position
	default_max_height_campaign = 500,
	default_max_height_battle = 500,
	related_panels_open = 0,
	panel_is_docked = true,
	panel_is_docked_and_displaced = false,
	displacing_panel = "",
	panel_is_visible = false,
	radar_width = 300,
	close_on_game_menu_opened = true,
	
	-- info button to page map
	info_button_to_page_map = {},
	
	-- registers that the page request that shall immediately follow is generated by back/forward
	-- buttons, so we should not add this page to the history queue
	next_page_request_is_from_history = false,
	
	-- should help pages display links to the game guide
	should_display_game_guide_links = true,
	
	-- cache the index button tooltips if we disable them
	help_panel_index_button_tooltip_text = false,
	menu_bar_index_button_tooltip_text = false
};


function help_page_manager:new()

	out.help_pages("");
	out.help_pages("");
	out.help_pages("");
	out.help_pages("*** help page system initialising ***");
	out.help_pages("");

	local hm = {};
	
	setmetatable(hm, self);
	self.__index = self;
	
	hm.hyperlink_click_listeners = {};
	hm.tooltip_mouseover_listeners = {};
	hm.active_tooltip_mouseover_listeners = {};
	hm.help_page_history = {};
	hm.info_button_to_page_map = {};
	
	hm.parser = get_link_parser();
	
	__help_page_manager = hm;
	
	-- set up listeners for the back/forward buttons
	core:add_listener(
		"help_page_previous_history",
		"ComponentLClickUp",
		function(context) return context.string == "button_hp_previous" end,
		function(context) hm:previous_history_button_clicked() end,
		true	
	);
	
	core:add_listener(
		"help_page_forward_history",
		"ComponentLClickUp",
		function(context) return context.string == "button_hp_next" end,
		function(context) hm:forward_history_button_clicked() end,
		true	
	);
	
	-- listen for the ? help panel button being clicked, and update the panel's visibility state
	core:add_listener(
		"help_page_close_button_listener",
		"ComponentLClickUp",
		function(context) return context.string == "button_help_panel" or context.string == "button_info" end,
		function(context)
			if hm.panel_is_visible then
				hm:panel_is_closing();
			else
				hm.panel_is_visible = true;
				
				-- make the title bar buttons visible
				hm:show_title_bar_buttons(true);
			end;
		end,
		true
	);
	
	-- listen for the close button on the panel being clicked, and update the panel's visibility state
	core:add_listener(
		"help_page_close_button_listener",
		"ComponentLClickUp",
		function(context) return context.string == "button_hp_close" end,
		function(context)
			hm:panel_is_closing();
		end,
		true
	);
		
	-- listen for the panel being moved
	core:add_listener(
		"help_page_panel_moved",
		"ComponentMoved",
		function(context) return context.string == "help_panel" end,
		function(context)
			if not hm:get_related_panel_open() then
				out.help_pages("Panel is now undocked");
				hm.panel_is_docked = false;
				
				if __game_mode == __lib_type_campaign then
					hm:stop_watch_for_lists_while_docked();
				end;
			end;
		end,
		true
	);
	
	-- set up listener for index being generated
	core:add_listener(
		"help_page_index_generated",
		"HelpPageIndexGenerated",
		true,
		function()
			hm:help_page_index_generated() 
		end,
		true
	);
	
	-- set up listener for button_info buttons on each panel
	core:add_listener(
		"help_page_button_info_listener",
		"ComponentLClickUp",
		function(context) return context.string == "button_info" end,
		function(context) hm:info_button_clicked(UIComponent(context.component)) end,
		true
	);
		
	-- listen for panels being opened and closed
	local panel_opened_event = "ScriptEventPanelOpenedCampaign";
	local panel_closed_event = "ScriptEventPanelClosedCampaign";
	local all_overrides_table = help_panel_position_overrides_campaign;
	
	if __game_mode == __lib_type_battle then
		panel_opened_event = "PanelOpenedBattle";
		panel_closed_event = "PanelClosedBattle";
		all_overrides_table = help_panel_position_overrides_battle;
	end;
	
	core:add_listener(
		"help_page_related_panel_opened",
		panel_opened_event,
		function(context)
			return not not all_overrides_table[context.string] 
		end,
		function() hm:related_panel_opened(true) end,
		true		
	);
	
	core:add_listener(
		"help_page_related_panel_closed",
		panel_closed_event,
		function(context)
			local override_table = all_overrides_table[context.string];
			return override_table and override_table.is_active;
		end,
		function(context) hm:related_panel_closed(context.string) end,
		true
	);
	
	hm.overrides_table = all_overrides_table;
	
	-- hiding and showing on events
	-- hides the panel if certain events are received (end turn sequence, battle sequence) and then shows it afterwards if previously hidden
	local hide_on_event = {};
	table.insert(hide_on_event, "ScriptEventPlayerBattleStartedSP");
	table.insert(hide_on_event, "ScriptEventPlayerFactionTurnEnd");
	
	local attempt_show_on_event = {};
	table.insert(attempt_show_on_event, "ScriptEventPlayerBattleCompletedSP");
	table.insert(attempt_show_on_event, "ScriptEventPlayerFactionTurnStart");
		
	for i = 1, #hide_on_event do
		core:add_listener(
			"help_page_hide_on_event_listener",
			hide_on_event[i],
			true,
			function()
				local uic = hm:get_uicomponent();
				-- HACK: SM: Disabling to fix error.
				if type(uic) ~= "userdata" then
				   return;
				end
				
				if uic:Visible() then
					hm:show_panel(false);
					
					if not hm:is_help_page_history_empty() and hm:get_last_help_page() ~= "__index" then
						hm.make_visible_at_next_opportunity = true;
					end;
				end;			
			end,
			true
		);
	end;
	
	for i = 1, #attempt_show_on_event do
		core:add_listener(
			"help_page_show_on_event_listener",
			attempt_show_on_event[i],
			true,
			function()
				if hm.make_visible_at_next_opportunity then
					hm.make_visible_at_next_opportunity = false;
					hm:show_panel(true);
					hm:dock_help_panel_if_appropriate();
				end;
			end,
			true
		);
	end;
	
	-- hide the panel if the game guide, esc menu or spell browser is opened
	if __game_mode == __lib_type_campaign then
		core:add_listener(
			"help_page_close_button_listener",
			"PanelOpenedCampaign",
			function(context) return context.string == "game_guide" or context.string == "spell_browser" or (context.string == "esc_menu_campaign" and hm.close_on_game_menu_opened) end,
			function(context)
				hm:show_panel(false);
			end,
			true
		);
	
	elseif __game_mode == __lib_type_battle then	
		core:add_listener(
			"help_page_close_button_listener",
			"PanelOpenedBattle",
			function(context) return context.string == "game_guide" or context.string == "spell_browser" or (context.string == "esc_menu_battle" and hm.close_on_game_menu_opened) end,
			function(context)
				hm:show_panel(false);
			end,
			true
		);
	end;
	
	return hm;
end;


function get_help_page_manager()
	if __help_page_manager then
		return __help_page_manager;
	end;
	
	return help_page_manager:new();
end;







--
--	get uicomponent
--

function help_page_manager:get_uicomponent()
	if self.uic_help_panel then
		return self.uic_help_panel;
	end;
	
	local uic_help_panel = find_uicomponent(core:get_ui_root(), "help_panel");
	
	self.uic_help_panel = uic_help_panel;

	return uic_help_panel;
end;






--
-- returns the ? button on the top bar
--

function help_page_manager:get_index_button()	
	local uic = find_uicomponent(core:get_ui_root(), "menu_bar", "button_help_panel");
	
	if not uic then
		script_error("ERROR: get_index_button() called but couldn't find index button to return - how can this be?");
	end;
	
	return uic;
end;






--
--	whether to display game guide links on help pages
--

function help_page_manager:display_game_guide_links()
	return self.should_display_game_guide_links;
end;


function help_page_manager:set_display_game_guide_links(value)
	if value == false then
		self.should_display_game_guide_links = false;
	else
		self.should_display_game_guide_links = true;
	end;
end;







--
--	set whether to close the help panel when the ESC menu is opened
--

function help_page_manager:set_close_on_game_menu_opened(value)
	if value == false then
		self.close_on_game_menu_opened = false;
	else
		self.close_on_game_menu_opened = true;
	end;
end;






--
--	functions to show/hide buttons on title bar - for intro battles
--

function help_page_manager:show_title_bar_buttons(value, exempt_close_button)

	out.help_pages("### show_title_bar_buttons() called, value is " .. tostring(value) .. ", title_bar_buttons_visible is " .. tostring(self.title_bar_buttons_visible));
	
	local uic_panel = self:get_uicomponent();
	
	if not uic_panel then
		script_error("ERROR: show_title_bar_buttons() called but couldn't find help page uicomponent");
		return false;
	end;
	
	set_component_visible_with_parent(value, uic_panel, "button_hp_previous");
	set_component_visible_with_parent(value, uic_panel, "button_hp_next");
	set_component_visible_with_parent(value, uic_panel, "button_hp_index");
	
	if not exempt_close_button then
		set_component_visible_with_parent(value, uic_panel, "button_hp_close");
		
		-- set the top bar into a minimised state if all buttons have been hidden
		-- local uic_top_bar_parent = find_uicomponent(uic_panel, "top_bar_parent");
		-- uic_top_bar_parent:SetState("min");
	end;
end;








--
--	saving and loading history
--

function help_page_manager:load_history_from_string(str)
	
	local help_page_history = self.help_page_history;
	local pointer = 1;
	
	while true do
		local next_separator = string.find(str, "#", pointer);
		
		if not next_separator then
			break;
		end;
		
		self:add_help_page_to_history(string.sub(str, pointer, next_separator - 1));
		
		pointer = next_separator + 1;
	end;
	
	self:print_help_page_history();
end;


function help_page_manager:help_page_history_to_string()
	local help_page_history = self.help_page_history;
	
	local str = "";
	
	for i = 1, #help_page_history do
		str = str .. help_page_history[i] .. "#";
	end;
	
	return str;
end;




--
--	adding help page to history
--

function help_page_manager:add_help_page_to_history(page_name)
	local help_page_history = self.help_page_history;
	
	local insert_pointer = self.history_pointer + 1;
	
	-- delete all history past this point
	while(help_page_history[insert_pointer]) do
		table.remove(help_page_history, insert_pointer);
	end;
	
	-- insert our page into the history if it's different from the most-recent page
	-- (to avoid having successive pages that are the same)
	if help_page_history[self.history_pointer] ~= page_name then
		table.insert(help_page_history, insert_pointer, page_name)
		self.history_pointer = insert_pointer;
	end;
	
	-- if our history is bigger than our max history size then trim some off the end
	if #help_page_history > self.help_page_history_max_size then
		table.remove(help_page_history, 1);
		self.history_pointer = self.history_pointer - 1;
	end;
end;


-- gets the name of the last viewed help page (false and a warning if none have been viewed)
function help_page_manager:get_last_help_page()
	if #self.help_page_history == 0 then
		script_error("WARNING: get_last_help_page() called but no help page has ever been viewed, returning false - it's best to check is_panel_visible() or is_help_page_history_empty() before calling this");
		return false;
	end;

	return self.help_page_history[#self.help_page_history];
end;


function help_page_manager:is_help_page_history_empty()
	return #self.help_page_history == 0;
end;


function help_page_manager:is_panel_visible()
	return self:get_uicomponent():Visible();
end;




--
--	retrieving forward/back history pages
--

function help_page_manager:get_previous_help_page()
	if self.history_pointer > 0 then
		self.history_pointer = self.history_pointer - 1;
	end;
	
	return self.help_page_history[self.history_pointer];
end;


function help_page_manager:get_forward_help_page()
	if self.history_pointer < #self.help_page_history then
		self.history_pointer = self.history_pointer + 1;
	end;
	
	return self.help_page_history[self.history_pointer];
end;


function help_page_manager:previous_help_pages_exist()
	return self.history_pointer > 1;
end;


function help_page_manager:forward_help_pages_exist()
	return self.history_pointer < #self.help_page_history;
end;


function help_page_manager:show_previous_page()
	self.history_pointer = self.history_pointer - 1;
	self.next_page_request_is_from_history = true;
	
	local previous_page = self.help_page_history[self.history_pointer];
	
	if previous_page == "__index" then
		-- self:get_uicomponent():InterfaceFunction("show_index");
		interface_function(self:get_uicomponent(), "show_index");
		
		self:enable_help_panel_index_button(false);		
	else
		self:check_hyperlink_click(previous_page);
		self:enable_help_panel_index_button(true);
	end;
end;


function help_page_manager:show_forward_page()
	self.history_pointer = self.history_pointer + 1;
	self.next_page_request_is_from_history = true;
		
	local forward_page = self.help_page_history[self.history_pointer];
	
	out.help_pages("show_forward_page() called, history pointer is now " .. tostring(self.history_pointer) .. " and forward_page is " .. tostring(forward_page));
	
	if forward_page == "__index" then
		--self:get_uicomponent():InterfaceFunction("show_index");
		interface_function(self:get_uicomponent(), "show_index")
		self:enable_help_panel_index_button(false);
	else
		self:check_hyperlink_click(forward_page);
		self:enable_help_panel_index_button(true);
	end;
end;


function help_page_manager:previous_history_button_clicked()
	self:show_previous_page();
end;


function help_page_manager:forward_history_button_clicked()
	self:show_forward_page();
end;


-- for external use - used for hyperlinks that bring up the index
function help_page_manager:show_index()
	self:prepare_to_display_page("__index");
	-- self:get_uicomponent():InterfaceFunction("show_index");
	interface_function(self:get_uicomponent(), "show_index")
end;










--
--	page and text display
--

-- called when the player closes the panel
function help_page_manager:panel_is_closing()
	out.help_pages("Panel has been closed by player");
	
	self:stop_watch_for_lists_while_docked();
	self.panel_is_visible = false;
	self.panel_is_docked = true;		-- mark panel as docked when it's closed, so that it will redock when opened
end;


function help_page_manager:show_panel(value)
	local uic_help_panel = self:get_uicomponent();
	
	if uic_help_panel then
		if value then
			uic_help_panel:SetVisible(true);
			self.panel_is_visible = true;
		else
			uic_help_panel:SetVisible(false);
			self.panel_is_docked = true;		-- mark panel as docked when it's closed, so that it will redock when opened
			self.panel_is_visible = false;
			
			if __game_mode == __lib_type_campaign then
				self:stop_watch_for_lists_while_docked();
			end;
		end;
	end;
end;


-- called by a help page prior to updating the panel with text in order to show the panel and clear its contents
function help_page_manager:prepare_to_display_page(link)
	local uic_help_panel = self:get_uicomponent();
	
	-- add page record to history unless it's been exempted
	if not self.next_page_request_is_from_history then
		self:add_help_page_to_history(link);
	end;
	
	self:print_help_page_history();
	
	self.next_page_request_is_from_history = false;

	-- make panel visible
	if not uic_help_panel:Visible() then
		self:show_panel(true);
	end;
	
	self:show_title_bar_buttons(true);
	
	-- clear page
	-- uic_help_panel:InterfaceFunction("clear_all_info_text");
	interface_function(uic_help_panel, "clear_all_info_text")
end;


-- called by a help page after it's finished updating the panel with text
-- docks the panel if appropriate, and updates the button states
function help_page_manager:page_finished_displaying()
	local uic_help_panel = self:get_uicomponent();
			
	-- do nothing if the panel is not visible
	if not uic_help_panel:Visible() then
		return;
	end;
	
	-- A panel override becomes pending when a related panel is opened but the help panel was not.
	-- If an override is pending then call related_panel_opened() as if the related panel had been opened after
	-- the help panel, in order to update the help panel position
	if self:get_related_panel_open() then
		self:related_panel_opened();
	end;
		
	-- dock the panel if appropriate
	self:dock_help_panel_if_appropriate();
	
	-- update state of all buttons on the help panel
	self:update_help_page_buttons();
end;


-- displays a line of text and returns a link to the newly created uicomponent for the line
function help_page_manager:display_text_line(key)
	local uic_help_panel = self:get_uicomponent();

	-- uic_help_panel:InterfaceFunction("add_info_text_entry", key);
	interface_function(uic_help_panel, "add_info_text_entry", key);
	
	return find_uicomponent(self.uic_help_panel, key);
end;


-- called when the code generates the index page
function help_page_manager:help_page_index_generated()
	local uic_help_panel = self:get_uicomponent();
	
	local uic_list = find_uicomponent(uic_help_panel, "listview", "list_box");
	
	local parser = self.parser;
		
	for i = 0, uic_list:ChildCount() - 1 do
		local uic_entry = UIComponent(uic_list:Find(i));
		
		local unparsed_text = uic_entry:GetStateText();
		local parsed_text = parser:parse_for_links(unparsed_text);
		
		uic_entry:SetStateText(parsed_text);
	end;
	
	if not self.next_page_request_is_from_history then
		self:add_help_page_to_history("__index");
	end;
	
	self.next_page_request_is_from_history = false;
	
	self:page_finished_displaying();
	
	self:print_help_page_history();
end;


-- Work out if we need to minimise the radar and/or any lists and "dock" the panel.
-- We dock if we're coming from a closed state and no override was applied
function help_page_manager:dock_help_panel_if_appropriate()
	local uic_help_panel = self:get_uicomponent();
			
	local screen_x, screen_y = core:get_screen_resolution();
	
	-- show and reposition the panel if appropriate
	if __game_mode == __lib_type_campaign then
		local cm = get_cm();
		local uim = cm:get_campaign_ui_manager();
		
		local related_panel_open = self:get_related_panel_open();
		
		out.help_pages("dock_help_panel_if_appropriate() called, related_panel_open: " .. tostring(related_panel_open) .. ", panel_should_cede_priority: " .. tostring(self:panel_should_cede_priority(related_panel_open)) .. ", panel_is_docked: " .. tostring(self.panel_is_docked));
		
		if (not related_panel_open or self:panel_should_cede_priority(related_panel_open)) and self.panel_is_docked then			
			out.help_pages("\thelp page is docking");
			
			self:stop_watch_for_lists_while_docked();
			
			-- move the component into the centre of the screen to ensure that it does not get in the way of the SimulatedClicks below
			uic_help_panel:MoveTo(screen_x, screen_y);
			
			local radar_animating = false;
			
			-- minimise the radar if it's visible
			local uic_radar_button = find_uicomponent(core:get_ui_root(), "radar_things", "radar_toggle");
			
			local radar_button_state = uic_radar_button:CurrentState();
			
			if uic_radar_button:Visible() and is_fully_onscreen(uic_radar_button) and (radar_button_state == "down" or radar_button_state == "hover" or radar_button_state == "active" or radar_button_state == "down_off") then
				-- radar is maximised, so minimise it
				uic_radar_button:SimulateClick();
				radar_animating = true;
			end;
			
			local uic_tabgroup_parent = find_uicomponent(core:get_ui_root(), "bar_small_top", "TabGroup");
			
			for i = 0, uic_tabgroup_parent:ChildCount() - 1 do
				local uic_tab_button = UIComponent(uic_tabgroup_parent:Find(i));
				
				if uic_tab_button:Visible() and uic_tab_button:CurrentState() == "selected" then
					uic_tab_button:SimulateClick();
					radar_animating = true;
				end;
			end;
			
			-- move the component into the "docked" position
			local help_panel_x = screen_x - uic_help_panel:Width();
			local help_panel_y = 83;
			
			-- if the radar or a list is animating, set the panel to be invisible and then make it visible again in a short while to give those components a chance to get out of the way
			if radar_animating then
				self:show_panel(false);
				cm:callback(
					function()
						uic_help_panel:MoveTo(help_panel_x, help_panel_y);
						self:show_panel(true);
						
						-- close the panel if any lists are opened
						self:watch_for_lists_while_docked();
					end, 
					0.25
				);
			else
				uic_help_panel:MoveTo(help_panel_x, help_panel_y);
				self:watch_for_lists_while_docked();
			end;
		end;
		
		-- set max height of panel to default
		self:set_max_height(self.default_max_height_campaign);
			
	elseif __game_mode == __lib_type_battle then
		local bm = get_bm();
		
		if not self:get_related_panel_open() then
			local uic_radar = find_uicomponent(core:get_ui_root(), "radar_group", "radar");
			
			local help_panel_x = screen_x - uic_help_panel:Width();
			
			local radar_x, radar_y = uic_radar:Position();
			local radar_width, radar_height = uic_radar:Dimensions();
			
			local help_panel_y = radar_y + radar_height;
			
			uic_help_panel:MoveTo(help_panel_x, help_panel_y);
		end;
	
		-- set max height of panel to default
		self:set_max_height(self.default_max_height_battle);
	end;
end;


-- set the max height of the panel
function help_page_manager:set_max_height(value)
	local uic_help_panel = self:get_uicomponent()
	if not uic_help_panel then
		script_error("ERROR: set_max_height() called but couldn't find panel uicomponent");
		return false;
	end;
	uic_help_panel:SetProperty("max_height", value);
end;


function help_page_manager:update_help_page_buttons()
	local uic_help_panel = self:get_uicomponent();
	
	-- update states of forward/back buttons
	local uic_button_hp_previous = find_uicomponent(uic_help_panel, "button_hp_previous");
	
	if uic_button_hp_previous then
		if self:previous_help_pages_exist() then
			uic_button_hp_previous:SetState("active");
		else
			uic_button_hp_previous:SetState("inactive");
		end;
	else
		script_error("WARNING: update_history_navigation_buttons() could not find uic_button_hp_previous, how can this be?");
	end;
	
	local uic_button_hp_forward = find_uicomponent(uic_help_panel, "button_hp_next");
	
	if uic_button_hp_forward then
		if self:forward_help_pages_exist() then
			uic_button_hp_forward:SetState("active");
		else
			uic_button_hp_forward:SetState("inactive");
		end;
	else
		script_error("WARNING: update_history_navigation_buttons() could not find uic_button_hp_forward, how can this be?");
	end;
	
	-- if the index page is being displayed then disable the index button, otherwise enabled it
	if not self:is_help_page_history_empty() and self:get_last_help_page() == "__index" then
		self:enable_help_panel_index_button(false);
	else
		self:enable_help_panel_index_button(true);
	end;
end;


-- enables or disables the index button on the panel
function help_page_manager:enable_help_panel_index_button(value)
	local uic = find_uicomponent(self:get_uicomponent(), "button_hp_index");
	
	if value == false then
		uic:SetState("inactive");
		self.help_panel_index_button_tooltip_text = uic:GetTooltipText();
		uic:SetTooltipText("", true);
	else
		uic:SetState("active");
		
		if self.help_panel_index_button_tooltip_text then
			uic:SetTooltipText(self.help_panel_index_button_tooltip_text, true);
		end;
	end;
end;


-- enables or disables the index button on the menu bar
function help_page_manager:enable_menu_bar_index_button(value)
	local uic = find_uicomponent(core:get_ui_root(), "menu_bar", "button_help_panel");
	
	if value == false then
		uic:SetState("inactive");
		self.menu_bar_index_button_tooltip_text = uic:GetTooltipText();
		uic:SetTooltipText("", true);
	else
		uic:SetState("active");
		
		if self.menu_bar_index_button_tooltip_text then
			uic:SetTooltipText(self.menu_bar_index_button_tooltip_text, true);
		end;
	end;
end;





--
--	watch for lists or radar being opened while docked (CAMPAIGN)
--

function help_page_manager:watch_for_lists_while_docked()	
	-- close the help panel if it's docked and one of the lists or the radar is expanded
	core:add_listener(
		"hpm_watch_for_radar_while_docked",
		"ComponentLClickUp",
		function(context) 
			return context.string == "radar_toggle" or 
				context.string == "tab_missions" or 
				context.string == "tab_events" or 
				context.string == "tab_units" or 
				context.string == "tab_regions" or 
				context.string == "tab_factions";
		end,
		function(context)
			local uic_panel = self:get_uicomponent();
			
			out.help_pages("watch_for_lists_while_docked() has detected a list being opened: " .. tostring(context.string));
			
			-- work out if the help panel is displaced (pushed to the left by a radar or list panel being opened) or whether it needs to be etc.
			local displacing_panel = context.string;
			
			if not self.panel_is_docked_and_displaced then
				-- the panel is not displaced and one of the list/radar buttons has been clicked - displace it to the left
				self.panel_is_docked_and_displaced = true;
				
				if displacing_panel == "radar_toggle" then
					self.radar_is_open = true;
				else
					self.displacing_panel = displacing_panel;
				end;
				
				local panel_x, panel_y = uic_panel:Position();
				uic_panel:MoveTo(panel_x - self.radar_width, panel_y);
				
			else
				
				if displacing_panel == "radar_toggle" then
					-- the radar is being toggled
					if self.radar_is_open then
						self.radar_is_open = false;
					else
						self.radar_is_open = true;
					end;
					
				elseif displacing_panel == self.displacing_panel then
					-- if the panel currently being toggled is the same as the one that's already open, then it's being closed
					self.displacing_panel = "";
				else
					-- the panel current being toggled is different to the one that's already open (or just the radar was open before) - record that this one is open
					self.displacing_panel = displacing_panel;
				end;
				
				-- if there is no longer a displacing panel and the radar is closed, the help panel is un-displaced and can redock
				if self.displacing_panel == "" and not self.radar_is_open then
					self.panel_is_docked_and_displaced = false;
					
					get_cm():callback(
						function()
							self:dock_help_panel_if_appropriate();
						end,
						0.2
					);
				end;
			end;
		end,
		true		
	);
end;


function help_page_manager:stop_watch_for_lists_while_docked()
	self.panel_is_docked_and_displaced = false;
	self.displacing_panel = "";
	self.radar_is_open = false;
	
	if __game_mode == __lib_type_campaign then
		core:remove_listener("hpm_watch_for_radar_while_docked");
	end;
end;








--
--	update state of panel
--

function help_page_manager:get_related_panel_open()
	for panel_name, override_table in pairs(self.overrides_table) do
		if override_table.is_active then
		
			-- if this related panel has to cede priority to another, and that one is open, then return that instead
			if override_table.cede_priority_to then
				if self.overrides_table[override_table.cede_priority_to].is_active then
					return override_table.cede_priority_to;
				end;
			end;
			
			return panel_name;
		end;
	end;
	
	return false;
end;


function help_page_manager:panel_should_cede_priority(panel_name)
	local override_table = self.overrides_table[panel_name];
	
	-- don't cede priority if we can't find the specified panel or it doesn't cede priority to any other panels
	if not override_table or not override_table.cede_priority_to then
		return false;
	end;
	
	if __game_mode == __lib_type_campaign then
		-- cede priority if the panel linked to is open
		return get_cm():get_campaign_ui_manager():is_panel_open(override_table.cede_priority_to);
	end;
	
	return false;
end;


-- boolean flag is true if the related panel opened second - i.e. the help panel was open first, and then a related panel was opened
function help_page_manager:related_panel_opened(help_panel_was_open_first)
	out.help_pages("related_panel_opened() called");
	
	local uic_help_panel = self:get_uicomponent();
	
	local screen_x, screen_y = core:get_screen_resolution();
	
	if __game_mode == __lib_type_campaign then
		local cm = get_cm();
		local uim = cm:get_campaign_ui_manager();
		
		for panel_name, override_table in pairs(self.overrides_table) do
			if uim:is_panel_open(panel_name) then
				out.help_pages("\tpanel " .. panel_name .. " is open");
				
				-- store whether the override table was active - this will be false if the override panel has just been opened, true if it was opened before
				-- and the player has requested a new help page
				local override_table_was_active = override_table.is_active;
				
				-- mark the override panel as being active
				override_table.is_active = true;
				
				-- if the help panel is not visible then don't do anything
				if not uic_help_panel:Visible() then
					out.help_pages("\thelp panel is not open");
					
				elseif is_string(override_table.cede_priority_to) and uim:is_panel_open(override_table.cede_priority_to) then
					out.help_pages("\tgiving precedent to open panel " .. tostring(override_table.cede_priority_to));
				
				elseif not override_table_was_active and (self:is_help_page_history_empty() or self:get_last_help_page() == "__index") then			
					out.help_pages("\thelp panel open at index, closing it");
					self:show_panel(false);
					
				elseif override_table.always_close and help_panel_was_open_first then			
					out.help_pages("\thelp panel was open, " .. panel_name .. " has opened and we are set to always close in this circumstance - closing");
					self:show_panel(false);
				
				else
					-- set and cache the priority of the help panel, if we need to
					if is_number(override_table.priority) then
						override_table.cached_priority = uic_help_panel:Priority();
						uic_help_panel:PropagatePriority(override_table.priority);
						core:get_ui_root():Adopt(uic_help_panel:Address());
					end;
					
					self.panel_is_docked = true;

					-- if the panel provides a max height override, set it on the panel
					local max_height_override = override_table.max_height;
					
					if is_number(max_height_override) then
						self:set_max_height(max_height_override);
					end;
					
					-- move the panel to the override position
					local override_x = override_table.x;
					local override_y = override_table.y;
					
					if override_x == "middle" then
						override_x = (screen_x / 2) - (uic_help_panel:Width() / 2);
						out.help_pages("\tsetting override_x to " .. override_x);
					end;
					
					if override_y == "middle" then
						override_y = (screen_y / 2) - (uic_help_panel:Height() / 2);
						out.help_pages("\tsetting override_y to " .. override_x);
					end;
					
					-- if the override values are less than zero then position the panel relative to the right/bottom of the screen
					if override_x < 0 then
						override_x = (screen_x + override_x) - uic_help_panel:Width();
					end;
					
					if override_y < 0 then
						override_y = (screen_y + override_y) - uic_help_panel:Height();
					end;
					
					uic_help_panel:MoveTo(override_x, override_y);
					
					out.help_pages("help_page_manager:related_panel_opened() has found an override panel " .. panel_name .. ", moving help panel to [" .. override_x .. ", " .. override_y .. "]");
					break;
				end;
			end;
		end;
	end;
	
	-- update state of all buttons on the help panel
	self:update_help_page_buttons();
end;


-- called when a panel that affects the state of the help panel (fullscreen panels like diplomacy) is closed
function help_page_manager:related_panel_closed(panel_name)
	out.help_pages("related_panel_closed() called");

	local uic_help_panel = self:get_uicomponent();
	
	if __game_mode == __lib_type_campaign then
		local cm = get_cm();
		local override_table = help_panel_position_overrides_campaign[panel_name];
		
		if not override_table then
			script_error("WARNING: related_panel_closed() called but couldn't find override table for supplied panel [" .. tostring(panel_name) .. "], how can this be?");
			return false;
		end;
		
		if override_table.is_active then		
			override_table.is_active = false;
			
			if not self.panel_is_visible then
				return;
			end;
			
			out.help_pages("help_page_manager:related_panel_closed() is redocking the help panel upon closure of panel " .. panel_name);
			
			-- restore priority of the help panel, if we need to
			if is_number(override_table.cached_priority) then
				uic_help_panel:PropagatePriority(override_table.cached_priority);
				core:get_ui_root():Adopt(uic_help_panel:Address());
				override_table.cached_priority = nil;
			end;
			
			-- a bit hacky - we should wait for some kind of notification that the radar panel has animated back on
			local redocking_wait_period = override_table.redocking_wait_period;
			
			-- always wait a little bit of time
			if not is_number(redocking_wait_period) then
				redocking_wait_period = 0.1;
			end;
			
			cm:callback(
				function()
					self:dock_help_panel_if_appropriate();
				end, 
				redocking_wait_period
			);
		end;
		
	elseif __game_mode == __lib_type_battle then
		-- todo
	end;
end













--
--	debug output
--

function help_page_manager:print_help_page_history()
	local print_func = false;
	
	out.help_pages("printing help page history:");
	for i = 1, #self.help_page_history do
		if i == self.history_pointer then	
			out.help_pages("\t" .. i .. ": " .. self.help_page_history[i] .. " << history pointer here");
		else
			out.help_pages("\t" .. i .. ": " .. self.help_page_history[i]);
		end;
	end;
end;














--
--	Hyperlink click listeners
--	This system listens for when a hyperlink is clicked on and calls the associated callback
--

function help_page_manager:start_hyperlink_click_listener()
	if self.hyperlink_click_listener_started then
		return;
	end;
	
	self.hyperlink_click_listener_started = true;
	
	core:add_listener(
		"hyperlink_click_listener",
		"ComponentLinkClicked",
		true,
		function(context)
			self:check_hyperlink_click(context.string);
		end,
		true
	);
end;


-- called by each help page instance to register a listener for its own individual url
function help_page_manager:register_hyperlink_click_listener(url, callback)
	if not is_string(url) then
		script_error("ERROR: register_hyperlink_click_listener() called but supplied url [" .. tostring(url) .. "] is not a string");
		return false;
	end;
	
	if not is_function(callback) then
		script_error("ERROR: register_hyperlink_click_listener() called but supplied callback [" .. tostring(callback) .. "] is not a function");
		return false;
	end;
	
	self:start_hyperlink_click_listener();
	
	local listener_entry = {url = url, callback = callback};
	
	if not self.hyperlink_click_listeners[url] then
		self.hyperlink_click_listeners[url] = {};
	end;
	
	table.insert(self.hyperlink_click_listeners[url], listener_entry);
end;


-- Called when some script wants to register that a hyperlink has been clicked - primarily the click event listener that listens
-- for hyperlinks being clicked, but also other functions that want to simulate this such as history buttons. Each individual page registers
-- a click listener with register_hyperlink_click_listener() above
function help_page_manager:check_hyperlink_click(url)
	local listener_list = self.hyperlink_click_listeners[url];
	
	if not listener_list then
		return;
	end;
	
	for i = 1, #listener_list do
		local current_listener = listener_list[i];
				
		if current_listener.url == url then
			current_listener.callback();
		end;
	end;
end;


function help_page_manager:stop_hyperlink_click_listener()
	self.hyperlink_click_listener_started = false;
	
	core:remove_listener("hyperlink_click_listener");
end;









----------------------------------------------------------------------------
--	Tooltip mouseover listener
----------------------------------------------------------------------------

function help_page_manager:start_tooltip_mouseover_listeners()
	if self.tooltip_mouseover_listeners_started then
		return;
	end;
	
	self.tooltip_mouseover_listeners_started = true;
		
	core:add_listener(
		"tooltip_mouseover_listener",
		"ComponentLinkMouseOver",
		true,
		function(context) self:check_tooltip_mouseover_list(context.string) end,
		true
	);
end;


function help_page_manager:register_tooltip_listener(tl)
	table.insert(self.tooltip_mouseover_listeners, tl);
	
	if not self.tooltip_mouseover_listeners_started then
		self:start_tooltip_mouseover_listeners();
	end;
end;


function help_page_manager:check_tooltip_mouseover_list(str)

	if str == "" then
		-- this is a mouse-off event, so find all (should only be one) active tooltip listeners
		-- and call their mouseoff event
		
		local tooltip_listeners = {};
		
		for i = 1, #self.active_tooltip_mouseover_listeners do
			table.insert(tooltip_listeners, self.active_tooltip_mouseover_listeners[i]);
		end;
		
		self.active_tooltip_mouseover_listeners = {};
		
		-- actually call all our callbacks
		for i = 1, #tooltip_listeners do
			tooltip_listeners[i]:link_mouseoff();
		end;
		
	else
		-- this is a mouse-on event, so go through our tooltip listeners
		-- and see if the link matches the supplied string
		local matching_tooltip_listeners = {};

		for i = 1, #self.tooltip_mouseover_listeners do
			local current_listener = self.tooltip_mouseover_listeners[i];
			
			if current_listener.link == str and not current_listener.is_active then
				table.insert(matching_tooltip_listeners, current_listener);
			end;
		end;
		
		-- process the matching listeners
		for i = 1, #matching_tooltip_listeners do
			local current_listener = matching_tooltip_listeners[i];
			table.insert(self.active_tooltip_mouseover_listeners, current_listener);
			current_listener:link_mouseon();
		end;
	end;
end;



function help_page_manager:stop_tooltip_mouseover_listeners()
	self.tooltip_mouseover_listeners_started = false;
	core:remove_listener("tooltip_mouseover_listener");
end;



function help_page_manager:info_button_clicked(uicomponent)
	out.help_pages("info_button_clicked()");
	out.help_pages(uicomponent_to_str(uicomponent));
		
	local info_button_to_page_map = self.info_button_to_page_map;
	
	for i = 1, #info_button_to_page_map do
		local current_mapping = info_button_to_page_map[i];
		
		if uicomponent_descended_from(uicomponent, current_mapping.parent_id) then
			if not current_mapping.component_test or current_mapping.component_test() then
				self:check_hyperlink_click(current_mapping.help_page);
				return;
			end;
		end;
	end;
	
	script_error("WARNING: info_button_clicked() called but couldn't find help page mapping to match parent id. See Help Page tab for path to info button component");
end;


function help_page_manager:register_help_page_to_info_button_mapping(help_page, info_button_parent_id, component_test)
	if not is_string(help_page) then
		script_error("ERROR: register_help_page_to_info_button_mapping() called but supplied help page [" .. tostring(help_page) .. "] is not a string");
		return false;
	end;
	
	if not is_string(info_button_parent_id) then
		script_error("ERROR: register_help_page_to_info_button_mapping() called but supplied info button parent id [" .. tostring(info_button_parent_id) .. "] is not a string");
		return false;
	end;
	
	if component_test and not is_function(component_test) then
		script_error("ERROR: register_help_page_to_info_button_mapping() called but supplied component test [" .. tostring(component_test) .. "] is not a function or nil");
		return false;
	end;
	
	local mapping = {};
	mapping.parent_id = info_button_parent_id;
	mapping.help_page = help_page;
	mapping.component_test = component_test;
	
	table.insert(self.info_button_to_page_map, mapping);
end;




























-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
--
--	HELP PAGES
--	This file provides library support for help pages
--
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

-----------------------------------------------------------------------------
--	various types of help page records
-----------------------------------------------------------------------------

function hpr_header(key)
	local retval = {};
	retval.key = key;
	retval.is_header = true;
	return retval;
end;


function hpr_normal(key)
	local retval = {};
	retval.key = key;
	retval.show_links = true;
	retval.use_small_text = true;
	return retval;
end;


function hpr_game_guide(key)
	local retval = {};
	retval.key = key;
	retval.show_links = true;
	retval.game_guide = true;
	retval.use_small_text = true;
	return retval;
end;


function hpr_linked(key)
	local retval = {};
	retval.key = key;
	retval.show_links = true;
	retval.use_small_text = true;
	return retval;
end;


function hpr_bulleted(key)
	local retval = {};
	retval.key = key;
	retval.is_bulleted = true;
	retval.show_links = true;
	retval.use_small_text = true;
	return retval;
end;


hpr_min_height_large = 54;
hpr_min_height_med = 40;


function hpr_campaign_camera_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_campaign_camera_controls = true;
	retval.show_modifier = true;
	retval.show_drag_modifier = true;
	retval.min_height = hpr_min_height_large;
	return retval;
end;


function hpr_campaign_camera_controls_alt(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_campaign_camera_controls_alt = true;
	retval.min_height = hpr_min_height_large;
	return retval;
end;


function hpr_battle_camera_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_battle_camera_controls = true;
	retval.min_height = hpr_min_height_large;
	return retval;
end;


function hpr_campaign_camera_facing_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_campaign_camera_facing_controls = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;


function hpr_battle_camera_facing_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_battle_camera_facing_controls = true;
	retval.show_modifier = true;
	retval.show_drag_modifier = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;


function hpr_campaign_camera_altitude_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_campaign_camera_altitude_controls = true;
	retval.show_modifier = true;
	retval.show_roll_modifier = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;


function hpr_battle_camera_altitude_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_battle_camera_altitude_controls = true;
	retval.show_modifier = true;
	retval.show_roll_modifier = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;


function hpr_battle_camera_speed_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_battle_camera_speed_controls = true;
	retval.show_modifier = true;
	retval.show_hold_modifier = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;


function hpr_battle_selection_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_battle_selection_controls = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;


function hpr_battle_multiple_selection_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_battle_multiple_selection_controls = true;
	retval.show_modifier = true;
	retval.show_drag_modifier = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;


function hpr_battle_movement_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_battle_movement_controls = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;


function hpr_battle_drag_out_formation_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_battle_drag_out_formation_controls = true;
	retval.show_modifier = true;
	retval.show_drag_modifier = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;


function hpr_battle_unit_destination_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_battle_unit_destination_controls = true;
	retval.show_modifier = true;
	retval.show_hold_modifier = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;


function hpr_battle_halt_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_battle_halt_controls = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;


function hpr_battle_attack_controls(key)
	local retval = {};
	retval.key = key;
	retval.is_cheat_sheet = true;
	retval.prevent_resizing = true;
	retval.is_battle_attack_controls = true;
	retval.show_modifier = true;
	retval.show_on_enemy_modifier = true;
	retval.min_height = hpr_min_height_med;
	return retval;
end;





-----------------------------------------------------------------------------
--	help page definition
-----------------------------------------------------------------------------

help_page = {
	hpm = false,
	link = "",
	content = {},
	always_use_small_text = false,
	always_use_normal_text = false,
	small_text_min_screen_height = 1100,
	hp_info_text_padding = 5
};


-----------------------------------------------------------------------------
--	help page declaration
-----------------------------------------------------------------------------

function help_page:new(link, ...)

	local hp = {};
	
	setmetatable(hp, self);
	self.__index = self;
	
	hp.link = link;
	hp.content = arg;
	hp.parser = get_link_parser();
	
	local hpm = get_help_page_manager();
	
	hpm:register_hyperlink_click_listener(link, function() hp:link_clicked() end);
	
	hp.hpm = hpm;
	
	return hp;
end;





function help_page:should_use_small_text()
	if self.always_use_small_text then
		return true;
	end;
	
	if self.always_use_normal_text then
		return false;
	end;

	-- get screen resolution and work out if we should use small or normal
	local screen_x, screen_y = core:get_screen_resolution();
	
	return screen_y < self.small_text_min_screen_height;
end;




-----------------------------------------------------------------------------
--	handle the link for this help page being clicked - does the actual
--	displaying of text on the page
-----------------------------------------------------------------------------

function help_page:link_clicked()
	local link = self.link;
	local hpm = self.hpm;

	-- If this page is currently being displayed then close the panel if it's visible, or allow the navigation but don't record it in history if it's not.
	-- This is to catch occurrences of the player repeatedly clicking a ? button on a panel - it makes the panel open and close as expected.
	if not hpm:is_help_page_history_empty() and hpm:get_last_help_page() == link and not hpm:forward_help_pages_exist() and not hpm.next_page_request_is_from_history then
		if hpm:is_panel_visible() then
			hpm:show_panel(false);
			return;
		else
			hpm.next_page_request_is_from_history = true;
		end;
	end;
	
	local content = self.content;
	
	out.help_pages("** Displaying help page [" .. link .. "]");
	
	-- register that this link has been clicked
	effect.set_advice_history_string_seen(link);
		
	-- clear existing box contents
	hpm:prepare_to_display_page(link);
	
	-- clear any currently-showning tooltip highlights
	if __game_mode == __lib_type_campaign then
		get_cm():get_campaign_ui_manager():unhighlight_all_for_tooltips();
	elseif __game_mode == __lib_type_battle then
		get_bm():get_battle_ui_manager():unhighlight_all_for_tooltips();
	end;
		
	-- go through all records and display them
	for i = 1, #content do
		self:append_help_page_record(content[i]);
	end;
	
	out.help_pages("");
	
	hpm:page_finished_displaying();
end;


-----------------------------------------------------------------------------
--	appends an individual help page record onto a page
-----------------------------------------------------------------------------

function help_page:append_help_page_record(record)
	
	local key = record.key;
	local hpm = self.hpm;
	
	-- only proceed if this is not a game guide link, or if it is and we're allowed to display game guide links
	if not record.game_guide or (record.game_guide and hpm:display_game_guide_links()) then
		record.is_active = true;
		
		-- display the line
		local uic_entry = hpm:display_text_line(key)
	
		if not uic_entry then
			script_error("ERROR: couldn't find uic_entry for key " .. tostring(key));
			return;
		end;
		
		local use_small_text = record.use_small_text or self:should_use_small_text();
		
		if record.is_header then
			self:set_record_state(uic_entry, record, "header");
		else
			
			if record.is_cheat_sheet then
				-- control cheat-sheet pages
				if record.is_campaign_camera_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_campaign_camera");
					
				elseif record.is_campaign_camera_controls_alt then
					self:set_record_state(uic_entry, record, "prelude_controls_campaign_camera_alt");
				
				elseif record.is_campaign_camera_facing_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_campaign_camera_facing");
				
				elseif record.is_campaign_camera_altitude_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_campaign_camera_altitude");
				
				elseif record.is_battle_camera_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_battle_camera");
					
				elseif record.is_battle_camera_facing_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_battle_camera_facing");
				
				elseif record.is_battle_camera_altitude_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_battle_camera_altitude");
				
				elseif record.is_battle_camera_speed_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_battle_camera_speed");
				
				elseif record.is_battle_selection_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_battle_selection");
				
				elseif record.is_battle_multiple_selection_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_battle_multiple_selection");
				
				elseif record.is_battle_movement_controls then 
					self:set_record_state(uic_entry, record, "prelude_controls_battle_unit_movement");
				
				elseif record.is_battle_drag_out_formation_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_battle_drag_out_formation");
				
				elseif record.is_battle_unit_destination_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_battle_unit_destinations");
				
				elseif record.is_battle_halt_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_battle_halt");
				
				elseif record.is_battle_attack_controls then
					self:set_record_state(uic_entry, record, "prelude_controls_battle_attacking");
				end;
			
			elseif use_small_text then
				if record.is_bulleted then
					self:set_record_state(uic_entry, record, "prelude_small_bullet_text");
				else
					self:set_record_state(uic_entry, record, "prelude_small_text");
				end;
			else
				if record.is_bulleted then
					self:set_record_state(uic_entry, record, "prelude_normal_bullet_text");
				else
					self:set_record_state(uic_entry, record, "prelude_normal_text");
				end;
			end;
			
			-- see if we need to show the modifier component
			if record.show_modifier then
				local uic_modifier = find_uicomponent(uic_entry, "modifier");
				if uic_modifier then
					if record.show_drag_modifier then
						uic_modifier:SetStateText(effect.get_localised_string("ui_text_replacements_localised_text_hp_battle_cheat_sheet_drag_modifier"));
					
					elseif record.show_roll_modifier then
						uic_modifier:SetStateText(effect.get_localised_string("ui_text_replacements_localised_text_hp_battle_cheat_sheet_roll_modifier"));
					
					elseif record.show_hold_modifier then
						uic_modifier:SetStateText(effect.get_localised_string("ui_text_replacements_localised_text_hp_battle_cheat_sheet_hold_modifier"));
					
					elseif record.show_on_enemy_modifier then
						uic_modifier:SetStateText(effect.get_localised_string("ui_text_replacements_localised_text_hp_battle_cheat_sheet_on_enemy_modifier"));
					end;
					
					uic_modifier:SetVisible(true);
				end;
			end;
		end;
		
		-- parse the localised text on this uicomponent
		local localised_text = ""
		
		if record.show_links then
			localised_text = self.parser:parse_for_links(uic_entry:GetStateText());
		else
			localised_text = self.parser:parse_for_tooltips(uic_entry:GetStateText());
		end;
		
		uic_entry:SetStateText(localised_text);
		
		-- resize the component
		local w, h, d = uic_entry:TextDimensions();
		if record.min_height and record.min_height > h then
			h = record.min_height;
		end;
		
		if not record.prevent_resizing then
			uic_entry:SetCanResizeHeight(true);
			uic_entry:SetCanResizeWidth(false);
			uic_entry:Resize(uic_entry:Width(), h + self.hp_info_text_padding);
		end;
		
		-- resize modifier if one is active
		if record.show_modifier then
			local uic_modifier = find_uicomponent(uic_entry, "modifier");
			uic_modifier:SetCanResizeHeight(true);
			uic_modifier:Resize(uic_modifier:Width(), uic_entry:Height());
			uic_modifier:SetCanResizeHeight(false);
		end;
		
		out.help_pages("displaying line [" .. localised_text .. "] with state [" .. uic_entry:CurrentState() .. "], component height is [" .. tostring(uic_entry:Height()) .. "] (resized: " .. tostring(not record.prevent_resizing) .. ")");
		
		uic_entry:SetCanResizeHeight(false);
		
		-- something is setting the component opacity to 100, so set it back to 0
		if record.is_header then
			uic_entry:SetOpacity(false, 0);
		end;
		
		-- force the list to refresh its height
		UIComponent(uic_entry:Parent()):Layout();
	end;
end;







-----------------------------------------------------------------------------
--	change the state of an existing record
-----------------------------------------------------------------------------

function help_page:set_record_state(uic, record, state, make_active)
	if make_active ~= false then
		make_active = true;
	end;

	if not record.is_howto or record.current_state ~= state then
		record.current_state = state;
		uic:SetState(state);
		
		if make_active then
			-- if this record is being made active, was not previously active and has some cached active
			-- state text, then set the state text to be this (as it will reinstate the tags)
			if record.cached_active_text and not record.is_active then
				uic:SetStateText(record.cached_active_text);
			end;
			
			record.is_active = true;
		else
			if record.is_active then	
				local localised_text = uic:GetStateText()
			
				-- if this record is being made inactive, was previously active and doesn't have any
				-- cached state text, then cache the state text so we can reinstate the tags later
				if not record.cached_active_text then
					record.cached_active_text = localised_text;
				end;	

				-- strip tags out of the text of this uicomponent
				uic:SetStateText(core:strip_tags_from_localised_text(localised_text));
			end;
			
			record.is_active = false;
		end;
	end;
end;



































tooltip_listener = {
	hpm = nil,
	is_active = false,
	link = "",
	mouseon_callback = false,
	mouseoff_callback = false
};


function tooltip_listener:new(link, mouseon_callback, mouseoff_callback)

	if not is_string(link) then
		script_error("ERROR: tooltip_listener:new() called but supplied link [" .. tostring(link) .. "] is not a string");
		return false;
	end;
	
	if not is_function(mouseon_callback) then
		script_error("ERROR: tooltip_listener:new() called but supplied mouseon callback [" .. tostring(mouseon_callback) .. "] is not a function");
		return false;
	end;
	
	if not is_function(mouseoff_callback) then
		script_error("ERROR: tooltip_listener:new() called but supplied mouseoff callback [" .. tostring(mouseoff_callback) .. "] is not a function");
		return false;
	end;

	local hpm = get_help_page_manager();
	local tl = {};
	
	setmetatable(tl, self);
	self.__index = self;

	tl.link = "tooltip:{{tt:" .. link .. "}}";
	tl.mouseon_callback = mouseon_callback;
	tl.mouseoff_callback = mouseoff_callback;
	
	hpm:register_tooltip_listener(tl);
	
	return tl;
end;


function tooltip_listener:link_mouseon()
	if not self.is_active then
		self.is_active = true;
		self:mouseon_callback();
	end;
end;



function tooltip_listener:link_mouseoff()
	if self.is_active then
		self.is_active = false;
		self:mouseoff_callback();
	end;
end;

















----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
--
--	LINK PARSER
--
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------


----------------------------------------------------------------------------
--	Definition
----------------------------------------------------------------------------


link_parser = {
	links = {},
	
	-- colour profiles now in ui_colours table
	link_colour_str = "col:help_page_link", 								-- 206, 100, 8
	visited_link_colour_str = "col:help_page_link_visited",					-- 168, 122, 84
	tooltip_colour_str = "col:help_page_link_inactive",						-- 255, 231, 127
	colour_str_terminator = "col"
};


----------------------------------------------------------------------------
--	Declaration
----------------------------------------------------------------------------

__link_parser = nil;

function link_parser:new()

	if __link_parser then
		return __link_parser;
	end;
	
	local lp = {};
	setmetatable(lp, self);
	self.__index = self;
	self.__tostring = function() return TYPE_LINK_PARSER end;
	
	lp.links = {};
	
	lp.parse_for_links_func = function(key, text)
		local link_record = lp.links[key];
		
		if not link_record then
			script_error("ERROR: couldn't find a link record for supplied key [" .. tostring(key) .. "]");
			return text;
		end;
		
		local script_link = link_record.script_link;
		
		if not link_record then
			script_error("record " .. key .. " doesn't exist !");
			return text;
		end;
		
		-- if this record has no tooltip key then don't include a tooltip tag
		if link_record.tooltip_key == "" then
			script_error("record " .. key .. " has no tooltip tag");
			return "[[url:" .. link_record.script_link .. "]]" .. text .. "[[/url]]";
		end;
		
		
		if effect.get_advice_history_string_seen(script_link) then
			-- player has seen this link before
			return "[[url:" .. link_record.script_link .. "]][[tooltip:{{tt:" .. link_record.tooltip_key .. "}}]][[" .. lp.visited_link_colour_str .. "]]" .. text .. "[[/" .. lp.colour_str_terminator .. "]][[/tooltip]][[/url]]";
		else
			-- player has not seen this link before
			return "[[url:" .. link_record.script_link .. "]][[tooltip:{{tt:" .. link_record.tooltip_key .. "}}]][[" .. lp.link_colour_str .. "]]" .. text .. "[[/" .. lp.colour_str_terminator .. "]][[/tooltip]][[/url]]";
		end;
	end;
	
	lp.parse_for_tooltips_func = function(key, text)
		local link_record = lp.links[key];
		
		if not link_record then
			script_error("ERROR: couldn't find a link record for supplied key [" .. tostring(key) .. "]");
			return "";
		end;
		
		-- if this record has no tooltip key then don't include any tags at all
		if not link_record or link_record.tooltip_key == "" then
			return text;
		end;
		
		return "[[tooltip:{{tt:" .. link_record.tooltip_key .. "}}]][[" .. lp.tooltip_colour_str .. "]]" .. text .. "[[/" .. lp.colour_str_terminator .. "]][[/tooltip]]";
	end;
	
	lp.parse_for_no_links_func = function(key, text)
		-- don't tag the text at all
		return text;
	end;
	
	__link_parser = lp;
	
	return lp;
end;


function get_link_parser()
	return link_parser:new();
end;


----------------------------------------------------------------------------
--	Adding link records
----------------------------------------------------------------------------

function link_parser:add_record(key, script_link, tooltip_key)
	if not is_string(key) then
		script_error("ERROR: add_record() called but supplied key [" .. tostring(key) .. "] is not a string");
		return false;
	end;
	
	if not is_string(script_link) then
		script_error("ERROR: add_record() called but supplied script link [" .. tostring(script_link) .. "] is not a string");
		return false;
	end;
	
	if not tooltip_key then
		tooltip_key = "";
	end;
	
	if not is_string(tooltip_key) then
		script_error("ERROR: add_record() called but supplied tooltip key [" .. tostring(tooltip_key) .. "] is not a string or nil");
		return false;
	end;
	
	local record = {};
	record.script_link = script_link;
	record.tooltip_key = tooltip_key;
	
	self.links[key] = record;
end;


----------------------------------------------------------------------------
--	Parse functions
----------------------------------------------------------------------------

function link_parser:parse_component_for_links(uic)
	if not is_uicomponent(uic) then
		script_error("ERROR: parse_component_for_links() called but supplied object [" .. tostring(uic) .. "] is not a uicomponent");
		return false;
	end;
	
	local parsed_text = self:parse(uic:GetStateText(), self.parse_for_links_func);
	
	if parsed_text then
		uic:SetStateText(parsed_text);
	end;
end;


function link_parser:parse_for_links(str)
	if not is_string(str) then
		script_error("ERROR: parse_for_links() called but supplied object [" .. tostring(str) .. "] is not a string");
		return false;
	end;
	
	return self:parse(str, self.parse_for_links_func);
end;


function link_parser:parse_component_for_tooltips(uic)
	if not is_uicomponent(uic) then
		script_error("ERROR: parse_component_for_links() called but supplied object [" .. tostring(uic) .. "] is not a uicomponent");
		return false;
	end;
	
	local parsed_text = self:parse(uic:GetStateText(), self.parse_for_tooltips_func);
	
	if parsed_text then
		uic:SetStateText(parsed_text);
	end;
end;


function link_parser:parse_for_tooltips(str)
	if not is_string(str) then
		script_error("ERROR: parse_for_tooltips() called but supplied object [" .. tostring(str) .. "] is not a string");
		return false;
	end;
	
	return self:parse(str, self.parse_for_tooltips_func);
end;


function link_parser:parse_for_no_links(str)
	if not is_string(str) then
		script_error("ERROR: parse_for_no_links() called but supplied object [" .. tostring(str) .. "] is not a string");
		return false;
	end;
	
	return self:parse(str, self.parse_for_no_links_func);
end;


-- for internal use only
function link_parser:parse(str, default_parse_func)
	local modified_str = str;
	local pointer = 1;
	local next_separator = 1;
	
	-- [[sl:key]]text[[/sl]]
	-- handle localised text lookup
	local start_tag = "[[sl_lookup]]";
	local end_tag = "[[/sl_lookup]]";
	
	while true do
		pointer = 1;
		next_separator = string.find(modified_str, start_tag, pointer);
		
		if not next_separator then
			break;
		end;
		
		local pre_text = string.sub(modified_str, pointer, next_separator - 1);
		
		pointer = next_separator + string.len(start_tag);
				
		next_separator = string.find(modified_str, end_tag, pointer);
		
		if not next_separator then
			script_error("ERROR: parse_string did not find a correctly-formed closing script-lookup tag. Script lookup tags are closed as follows: [[/sl_lookup]]. String is: " .. modified_str);
			return false;
		end;
		
		local lookup_text = string.sub(modified_str, pointer, next_separator - 1);
		
		pointer = next_separator + string.len(end_tag);
		
		local post_text = string.sub(modified_str, pointer);
		
		modified_str = pre_text .. effect.get_localised_string(lookup_text) .. post_text;
	end;
			
	-- [[sl:key]]text[[/sl]]
	-- default tag interpreter
	local start_tag_open = "[[sl:";
	local start_tag_close = "]]";
	end_tag = "[[/sl]]";
	
	while true do
		pointer = 1;
		next_separator = string.find(modified_str, start_tag_open, pointer);
		
		if not next_separator then
			break;
		end;
		
		local pre_text = string.sub(modified_str, pointer, next_separator - 1);
		
		pointer = next_separator + string.len(start_tag_open);
		
		next_separator = string.find(modified_str, start_tag_close, pointer);
		
		if not next_separator then
			script_error("ERROR: parse_string did not find a correctly-formed opening script-link tag. Script link tags are opened as follows: [[sl:link_name]]. String is: " .. modified_str);
			return false;
		end;
		
		local link_key = string.sub(modified_str, pointer, next_separator - 1);
		
		pointer = next_separator + string.len(start_tag_close);
		
		next_separator = string.find(modified_str, end_tag, pointer);
		
		if not next_separator then
			script_error("ERROR: parse_string did not find a correctly-formed closing script-link tag. Script link tags are closed as follows: [[/sl]]. String is: " .. modified_str);
			return false;
		end;
		
		local link_text = string.sub(modified_str, pointer, next_separator - 1);
		
		pointer = next_separator + string.len(end_tag);
		
		local post_text = string.sub(modified_str, pointer);
		
		modified_str = pre_text .. default_parse_func(link_key, link_text) .. post_text;
	end;
	
	-- [[sl_link:key]]text[[/sl_link]]
	-- this tag forces the text to be interpreted as a link
	start_tag_open = "[[sl_link:";
	start_tag_close = "]]";
	end_tag = "[[/sl_link]]";
	
	while true do
		pointer = 1;
		next_separator = string.find(modified_str, start_tag_open, pointer);
		
		if not next_separator then
			break;
		end;
		
		local pre_text = string.sub(modified_str, pointer, next_separator - 1);
		
		pointer = next_separator + string.len(start_tag_open);
		
		next_separator = string.find(modified_str, start_tag_close, pointer);
		
		if not next_separator then
			script_error("ERROR: parse_string did not find a correctly-formed opening script-link tag (forcing link). Script link tags are opened as follows: [[sl_link:link_name]]. String is: " .. modified_str);
			return false;
		end;
		
		local link_key = string.sub(modified_str, pointer, next_separator - 1);
		
		pointer = next_separator + string.len(start_tag_close);
		
		next_separator = string.find(modified_str, end_tag, pointer);
		
		if not next_separator then
			script_error("ERROR: parse_string did not find a correctly-formed closing script-link tag (forcing link). Script link tags are closed as follows: [[/sl_link]]. String is: " .. modified_str);
			return false;
		end;
		
		local link_text = string.sub(modified_str, pointer, next_separator - 1);
		
		pointer = next_separator + string.len(end_tag);
		
		local post_text = string.sub(modified_str, pointer);
				
		modified_str = pre_text .. self.parse_for_links_func(link_key, link_text) .. post_text;
	end;
	
	-- [[sl_tooltip:key]]text[[/sl_tooltip]]
	-- this tag forces the text to be interpreted as a tooltip
	start_tag_open = "[[sl_tooltip:";
	start_tag_close = "]]";
	end_tag = "[[/sl_tooltip]]";

	while true do
		pointer = 1;
		next_separator = string.find(modified_str, start_tag_open, pointer);
		
		if not next_separator then
			break;
		end;
		
		local pre_text = string.sub(modified_str, pointer, next_separator - 1);
		
		pointer = next_separator + string.len(start_tag_open);
		
		next_separator = string.find(modified_str, start_tag_close, pointer);
		
		if not next_separator then
			script_error("ERROR: parse_string did not find a correctly-formed opening script-link tag (forcing tooltip). Script link tags are opened as follows: [[sl_tooltip:link_name]]. String is: " .. modified_str);
			return false;
		end;
		
		local link_key = string.sub(modified_str, pointer, next_separator - 1);
		
		pointer = next_separator + string.len(start_tag_close);
		
		next_separator = string.find(modified_str, end_tag, pointer);
		
		if not next_separator then
			script_error("ERROR: parse_string did not find a correctly-formed closing script-link tag (forcing tooltip). Script link tags are closed as follows: [[/sl_tooltip]]. String is: " .. modified_str);
			return false;
		end;
		
		local link_text = string.sub(modified_str, pointer, next_separator - 1);
		
		pointer = next_separator + string.len(end_tag);
		
		local post_text = string.sub(modified_str, pointer);
		
		modified_str = pre_text .. self.parse_for_tooltips_func(link_key, link_text) .. post_text;
	end;
		
	return modified_str;
end;











----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
--
--	TOOLTIP PATCHER
--	This system kicks in when a custom tooltip is displayed, and if it's a tooltip that
--	we're interested it replaces the contents of the tooltip with info from the db
--
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------

__tooltip_patcher = nil;


----------------------------------------------------------------------------
--	Definition
----------------------------------------------------------------------------


tooltip_patcher = {
	layout_key = "",
	tl = false
};


----------------------------------------------------------------------------
--	Declaration
----------------------------------------------------------------------------




function tooltip_patcher:new(layout_key)
	
	if not is_string(layout_key) then
		script_error("ERROR: add_tooltip_patcher() called but supplied layout key [" .. tostring(key) .. "] is not a string");
		return false;
	end;
	
	local tp = {};
	
	setmetatable(tp, self);
	self.__index = self;
	
	tp.layout_key = layout_key;
		
	return tp;
end;


function tooltip_patcher:set_layout_data(layout_string, ...)

	if not is_string(layout_string) then
		script_error("ERROR: set_layout_data() called but supplied layout string [" .. tostring(layout_string) .. "] is not a string");
		return false;
	end;
	
	self.layout_string = layout_string;

	if layout_string == "tooltip_title_and_text" then
		local title_string_key = arg[1];
		local text_string_key = arg[2];
		
		if not is_string(title_string_key) then
			script_error("ERROR: set_layout_data() called but supplied title key [" .. tostring(title_string_key) .. "] is not a string");
			return false;
		end;
		
		if not is_string(text_string_key) then
			script_error("ERROR: set_layout_data() called but supplied text key [" .. tostring(text_string_key) .. "] is not a string");
			return false;
		end;
		
		self.title_string_key = arg[1];
		self.text_string_key = arg[2];
	
		self.tl = tooltip_listener:new(
			self.layout_key, 
			function() self:tooltip_created_title_and_text() end,
			function() self:tooltip_destroyed() end
		);
	
	
	elseif layout_string == "tooltip_text_only" then
		local text_string_key = arg[1];
				
		if not is_string(text_string_key) then
			script_error("ERROR: set_layout_data() called but supplied text key [" .. tostring(text_string_key) .. "] is not a string");
			return false;
		end;

		self.text_string_key = arg[1];
	
		self.tl = tooltip_listener:new(
			self.layout_key, 
			function() self:tooltip_created_text_only() end,
			function() self:tooltip_destroyed() end
		);
	
	-- add more layouts here if necessary
	else		
		script_error("ERROR: tooltip_patcher:new() called but don't know how to deal with the supplied layout [" .. tostring(layout_string) .. "]. Either add script to cope with it or change the layout");
	end;
end;


function tooltip_patcher:tooltip_created_title_and_text()

	local uic_tooltip = find_uicomponent(core:get_ui_root(), self.layout_string);
	
	if not uic_tooltip then
		script_error("ERROR: tooltip_created_title_and_text() couldn't find tooltip component. Layout key is " .. self.layout_key);
		return false;
	end;
	
	local uic_title = find_uicomponent(uic_tooltip, "title");
	
	if not uic_title then
		script_error("ERROR: tooltip_created_title_and_text() couldn't find title component. Layout key is " .. self.layout_key);
		return false;
	end;
	
	local uic_text = find_uicomponent(uic_tooltip, "text");
	
	if not uic_text then
		script_error("ERROR: tooltip_created_title_and_text() couldn't find description component. Layout key is " .. self.layout_key);
		return false;
	end;
	
	local localised_title = effect.get_localised_string(self.title_string_key);
	
	if localised_title == "" then
		script_error("ERROR: couldn't find localised title corresponding to key " .. self.title_string_key);
		return false;
	end;
	
	local localised_text = effect.get_localised_string(self.text_string_key);
	
	if localised_text == "" then
		script_error("ERROR: couldn't find localised description corresponding to key " .. self.text_string_key);
		return false;
	end;
	
	uic_title:SetStateText(localised_title);
	uic_text:SetStateText(localised_text);
end;


function tooltip_patcher:tooltip_created_text_only()

	local uic_tooltip = find_uicomponent(core:get_ui_root(), self.layout_string);
	
	if not uic_tooltip then
		script_error("ERROR: tooltip_created_title_and_text() couldn't find tooltip component. Layout key is " .. self.layout_key);
		return false;
	end;
		
	local uic_text = find_uicomponent(uic_tooltip, "text");
	
	if not uic_text then
		script_error("ERROR: tooltip_created_title_and_text() couldn't find description component. Layout key is " .. self.layout_key);
		return false;
	end;
	
	local localised_text = effect.get_localised_string(self.text_string_key);
	
	if localised_text == "" then
		script_error("ERROR: couldn't find localised description corresponding to key " .. self.text_string_key);
		return false;
	end;
	
	uic_text:SetStateText(localised_text);
end;



function tooltip_patcher:tooltip_destroyed()
	-- don't need to do anything here
end;








